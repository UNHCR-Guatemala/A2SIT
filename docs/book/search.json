[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Admin2 Severity Index Tool",
    "section": "",
    "text": "Welcome\nThis is the detailed documentation of the Admin2 Severity Index Tool (A2SIT), which was developed by the UNCHR.\nThe aim of this documentation is to explain in detail:"
  },
  {
    "objectID": "index.html#what-is-the-a2sit-app",
    "href": "index.html#what-is-the-a2sit-app",
    "title": "Admin2 Severity Index Tool",
    "section": "What is the A2SIT app?",
    "text": "What is the A2SIT app?\nThe A2SIT app is a browser-based app which aims to measure “Severity” at the Admin-2 level, in order to help direct community-based protection interventions. It takes a set of user-input data and uses it to build a composite indicator of severity, as well as providing a detailed analysis of the data.\nPeter maybe add some more info about the context here, or in the next chapter?"
  },
  {
    "objectID": "index.html#using-the-app",
    "href": "index.html#using-the-app",
    "title": "Admin2 Severity Index Tool",
    "section": "Using the app",
    "text": "Using the app\n\nThe app is hosted online here. To begin using the app, you have to download the input data template, or download the example data set.\nThe app includes plenty of in-app guidance and hints, but the full documentation is found in this online book - in particular go to Chapter 2 to learn about the app layout, and Chapter 3 to learn how to upload your data.\nAs the app is wrapped in an R package, it is also possible to install and run it locally: this is explained more in Chapter 12."
  },
  {
    "objectID": "index.html#limitations",
    "href": "index.html#limitations",
    "title": "Admin2 Severity Index Tool",
    "section": "Limitations",
    "text": "Limitations\nThe app gives quite a lot of flexibility in that any indicator set can be used, and the structure of the index can be edited by the user. Within the app, there are also some methodological options such as the aggregation method.\nHowever, the app is set up to take Admin-2 level data. This is for the purposes of being able to map the indicators, so your data must:\n\nBe from a single country\nBe at the Admin-2 level\n\nIn other words, it is not currently possible to analyse international data. However, this can be done with the COINr package, upon which the app is based, if you are comfortable working in R.\nOn the methodological side, consider that composite indicators are an imprecise science, and they are built using a number of assumptions, and most likely an incomplete data set due to data limitations. A composite indicator should not be viewed as a precise measure, rather as a an indication of the concept you are trying to measure. You should always investigate the raw data as well as the composite index scores, to find out why a given region scores high or low. The A2SIT app is designed to help in this respect, allowing to drill down for any given region."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "1  What is A2SIT?",
    "section": "",
    "text": "Here we explain what the A2SIT is, the motivation behind it etc. I leave this section to Peter + team.\nWe could put also information about indicators here or in chapters in this book."
  },
  {
    "objectID": "layout.html#main-window",
    "href": "layout.html#main-window",
    "title": "2  App layout",
    "section": "2.1 Main window",
    "text": "2.1 Main window\nThere is not much to say about the main window, since it is different for each tab, and is described in much more detail in the following chapters. Suffice to say here that the buttons on the welcome screen include the guided tour, another button “Data input” which takes you to the “Upload” tab, and the “Know more” button which takes you to this online book.\nDepending on the size of your screen, the main window can sometimes become cluttered. Two ways to improve this are:\n\nMinimise the sidebar (see next section)\nUse the “zoom” function in your browser. E.g. on Chrome hold the “Ctrl” button and scroll the mouse wheel to zoom out - this will make the text smaller but you will be able to see more content at once. You can also zoom in if you need to!"
  },
  {
    "objectID": "layout.html#sidebar",
    "href": "layout.html#sidebar",
    "title": "2  App layout",
    "section": "2.2 Sidebar",
    "text": "2.2 Sidebar\nClicking on any element in the sidebar will take you to the corresponding tab. Keep in mind that you need to upload your data first before any of the remaining tabs will have any content. The app is built to analyse your data, so if you haven’t put any data in, it doesn’t have much to tell you!\nStart at the “Upload” tab to upload your data. Once you have completed that tab, click on the “Analyse” tab, and so on.\nTo make more space in the main window, you can minimise the sidebar by clicking the button (highlighted in the picture below): hovering over the sidebar will maximise it. Clicking the button again will restore the sidebar completely."
  },
  {
    "objectID": "layout.html#header",
    "href": "layout.html#header",
    "title": "2  App layout",
    "section": "2.3 Header",
    "text": "2.3 Header\nThe header contains several useful features which can be accessed at any time.\n\nOn the right side, the help icon gives a pop-up help window. The window is different for each tab, and gives specific help for that tab. However, the most detailed help is available in this book.\nThe “Bookmark session” button can be used to generate a link which allows you to return your app session in the future, and can be shared with others. This is generally only useful once you have uploaded data. In that case, at any point in the app, copy the bookmark link. You can put this link back in your browser at any point to return to the same point in the app, with your data saved. Keep in mind that:\n\nThe bookmark link takes you back to the exact point when you saved: it will not remember anything you did after you created the bookmark\nPlease don’t create more bookmarks than necessary - each one takes up server space\nWe may delete old bookmark files if necessary, to avoid overloading the server space if necessary. To add a policy here maybe, if we need to\n\nFinally in the header, the “Export” button can be used to download the results as they stand either to Excel or as a file that can be read by R.\nIf downloaded to Excel, the file will contain a number of tabs showing the results on both the 1-100 scale and the categorical 1-5 scale, for all scenarios. It also records the analysis tables, and metadata such as the weights and index structure.\nIf downloaded to R, the file can be loaded into R and will contain the “coin”, which is an object encapsulating a composite indicator and used by the COINr package, which is the basis of the A2SIT app calculations. See COINr documentation for more details on how to work with coins."
  },
  {
    "objectID": "data_input.html#template",
    "href": "data_input.html#template",
    "title": "3  Data input",
    "section": "3.1 Template",
    "text": "3.1 Template\nThe A2SIT app generates customised templates for each country. To download the template, select your country from the dropdown menu, then click the “Download country template” button.\n\nThe dropdown menu contains all the countries currently supported by the app1.\nThe next step is to fill in the template with your data. Opening the template, you will find that it has three tabs:\n\nIntro: instructions on how to fill in the template\nData: this is where you enter your indicator data\nStructure: this defines the structure of the index\n\nThe first tab is simply information and is ignored by the A2SIT app. We will also walk through the compilation of the spreadsheet here. Importantly, do not change the names of the Data and Structure tabs: these are tab names expected by the app.\n\n3.1.1 Data\nThe data tab contains a table which looks something like this:\n\nIn this table (excluding the metadata rows/columns), each row represents one Admin 2 region, and each column is one indicator.\nThe admin2Pcode column has the main codes used by the app, and this is automatically filled in depending on the country you have selected. These codes must not be edited because they are used to generate the maps later on in the app. The Name column has the corresponding name of each region. These names may be edited if you wish, although it is recommended not to edit them unless they contain spelling errors etc.\nThe next columns to the right are the data columns: this is where you should paste your indicator data. The number of columns here will depend on how many indicators you have. You can expand the table as far as you want. Consider some important rules though:\n\nAll indicator data must be numerical. You cannot enter words like “yes”/“no”, or categories such as “XL”, “L”, etc. The app only understands numerical indicator data. Also data that looks numerical, like “10 million” will not work: it should be 10000000!\nEach indicator data column should be accompanied by the metadata cells above it (name, group, direction, etc). Copy these cells as far as necessary. Do not leave metadata cells with no indicator data below them (delete these if this happens).\nTry to fill in data for every Admin2 code. Admin2 codes with no indicator data will be deleted by the app.\nDo not input data for rows where there are no Admin2 codes.\nMake sure each indicator has at least some data available. Indicators with no data can still be input into the app, but they will be automatically removed.\n\nThe best way to see what the correctly-formatted input data looks like is to simply download the example data set.\nThe row immediately above the indicator data contains the indicator code. These should be short unique codes which identify the indicator. Ideally these should be about 8 characters long or less, have no spaces, and should start with a letter (not a number). Examples could be “GDPpc”, “Migrants”, “Gini”. These will be used in some plots in the app, so it will help you if they are descriptive.\nThe next row above is the indicator name. These can be longer indicator names which will also be displayed in the app. Examples can be “GDP per capita”, “Gini coefficient” and so on.\nThe row above the indicator name is the group to which the indicator belongs in the level immediately above it. This defines the structure of the index and is explained in detail in the Structure section below.\nThe direction row defines the direction of each indicator. An indicator that shares the same “direction” as the index should have a “1” - such indicators in the context of Severity could be rates of domestic violence, or the number of displaced people. Higher values of these indicators imply higher severity. On the other hand, indicators such as coverage of public services, number of hospitals, etc run in the opposite direction: higher values imply less severity, therefore they should be assigned a direction of “-1”. The direction row can only take values of -1 or 1.\nFinally, the initial weight row gives a weight for each indicator. It is recommended to leave these all at “1” (representing equal weighting) unless you have good reasons for doing otherwise. The weights are used in the aggregation step later in the app to calculate the index scores, and can be used to increase or decrease the contribution of each indicator. However, weighting can be complex and highly subjective. If you do wish to adjust weights, consider that weights are relative within each aggregation group: they will be rescaled to sum to 1 within each group by the app. In other words, if we have three indicators in a group with weights 1, 1, and 1, they will each get a weight of 1/3.\n\n\n3.1.2 Structure\nThe “Structure” tab contains a table which defines the structure of the index. This is pre-compiled so there is no need to edit it unless you want to. However, it is a little more complex than the data tab.\n\n\n\nThe “Structure” tab from the example data set.\n\n\nEach row in the table gives details about one of the aggregates created by aggregating indicators together, with columns describing their attributes:\n\niCode is the code assigned to the aggregate.\nParent is the parent iCode: this defines which group the aggregate is in, in the level immediately above.\niName is a longer name assigned to the aggregate.\nLevel is the level in the framework, where 1 is the indicator level, 2 is the level created by aggregating indicators, and so on.\nWeight is the weight assigned to the aggregate. As mentioned previously, weights are relative within aggregation groups.\n\nThe iCode, Parent and Level columns together define the structure of the index. For example, in the example above the first four aggregates (at level 2) are defined as belonging to the “Socio_econ” group in level 3, according to the Parent column. The “Socio_econ” aggregate itself is defined in row 23 as belonging to the “vulnerabilidad” dimension, in level 4. Finally, the “Vulnerabilidad” dimension itself is one of four main dimensions of the “MVI”, which is the top level index at level 5.\nNotice that all the iCodes with Level = 2 are the entries in the “Group” row of the Data tab. This is to define where in the index each group is positioned.\nYou can edit the Structure table to include any number of aggregation groups and levels. However, keep in mind:\n\nEvery indicator or aggregate must have a parent, unless it is at the top level. You cannot define a parent that is more than one level above - if needed, define intermediate aggregates with only one indicator/aggregate.\nAll the codes in the “Group” row of the Data tab must be included in the Structure table.\n\nThe “Structure” table is in fact a simplified version of the “iMeta” table that is used in the COINr package upon which the A2SIT app is based. If you run into problems, or want to learn more about these input tables, you may wish to read the relavant COINr documentation page."
  },
  {
    "objectID": "data_input.html#upload",
    "href": "data_input.html#upload",
    "title": "3  Data input",
    "section": "3.2 Upload",
    "text": "3.2 Upload\nOnce the template has been correctly compiled, you are ready to upload it to the app.\n\nOn the “Upload” tab, first make sure you have selected the correct country in the dropdown, then browse to the your input data file and click the “Load” button. At this point, either the data upload will be successful or not. Here’s what to do.\n\n3.2.1 Successful\n\nIf the data upload is successful, the app should give several immediate outputs. First, a confirmation message that the upload was successful, then some summary information and possibly some messages.\nThe summary information will consist of a header which reports the country name, and also the number of indicators and regions.\n\nBelow this will be a sunburst plot of the framework you have specified, which should look something like this:\n\nThis is a plot of the index framework as specified in the Structure table. Hovering over segments will show indicator names, and clicking on segments will zoom in on lower levels. Double click to reset the plot. Like most plots in the app, a snapshot of the plot can be downloaded as a png file by clicking the small camera icon in the upper right of the plot.\nThe framework plot also shows the effective weight of each indicator and aggregate in the framework, as a result of the weights specified and the index structure, as the angle of each segment. Notice that where dimensions have more indicators, these are effectively (individually) weighted less. This is important to consider in defining the index structure.\n\nFinally, there may be some additional messages in the “Messages” box. In our example, we receive several messages - these relate to the fact that the app has detected some indicators with no data points and removed them (since they cannot be used in the calculations). Furthermore, it has found some aggregate groups with no “children” (indicators) defined in them. These empty groups also cannot be used in the calculation and so are removed. Check these messages carefully to ensure the app is not doing anything you don’t want to do.\nFrom here, if you are happy with the details reported by the app, you can move to the next tab.\n\n\n3.2.2 Unsuccessful\n\nIf you do have trouble uploading your data, don’t worry! The input is a little complex but the app will try to tell you what the problem is.\nIf the upload is unsuccessful, the app should report a helpful error message in the “Messages” box. For example:\n  \nTry to address the problem reported by the app. There may be more than one problem but the app will only report the first one it finds, so you may need to upload more than once to correct multiple problems. If you have trouble, re-read very carefully the rules in the sections above and check the example data set. Common problems could be:\n\nMismatch between Structure and Data tables: remember that codes are case-sensitive, and cross check very carefully to ensure that all group names from the Data table are in the Structure table.\nNon-numeric data: make sure each column of data is actually formatted as numeric. Even it looks like a number, Excel may have interpreted it as text. In Excel, a cell formatted as a number will be right-aligned, whereas text is left-aligned (see below).\n\n\n\nAltering spreadsheet: try above all to avoid modifying the spreadsheet in unexpected ways. For example, do not add extra or numbers in cells near the tables. Do not change the names of required columns, and don’t move tables, or rename tabs. You CAN add extra tabs to the spreadsheet with other calculations as the app will only look for the Data and Structure tabs."
  },
  {
    "objectID": "data_input.html#whats-next",
    "href": "data_input.html#whats-next",
    "title": "3  Data input",
    "section": "3.3 What’s next",
    "text": "3.3 What’s next\nFrom here, things get a lot smoother: the app should now work with fairly minimal interventions on your part. Move to the “Analysis” tab to begin analysing your data!"
  },
  {
    "objectID": "data_input.html#footnotes",
    "href": "data_input.html#footnotes",
    "title": "3  Data input",
    "section": "",
    "text": "This list represents the countries for which Admin 2 shape files are available for mapping.↩︎"
  },
  {
    "objectID": "analysis.html#analysis-table",
    "href": "analysis.html#analysis-table",
    "title": "4  Indicator analysis",
    "section": "4.1 Analysis table",
    "text": "4.1 Analysis table\nThe main output of this tab is the the analysis table, which gives one row for each indicator and in particular flags any potential statistical issues by highlighting cells in yellow.\n\nHere, “statistical issues” refers to problems identified automatically for each indicator. These should be treated as flags, over which you have the final decision whether they constitute a real problem or not. Here, each column is explained in more detail.\nThe first column, % availability refers to the percentage of data availability for that indicator. This is in a way the most important column. Here, if an indicator has less than 66% data availability, it will be flagged (highlighted yellow). Consider that 66% is a subjective threshold, although it is often used in the context of composite indicators. If the indicator has less, it could potentially be considered for removal unless it is very important to keep it. Indicators with very low data availability (less than 50%) should ideally not be included unless there is a very strong reason to do so.\nThe % same column reports the number of data points that share a single common value. For example, 50% of points are zero, this will be 50%. It is flagged if greater than 50%. The idea here is to point to indicators which have a low power in discriminating between Admin 2 regions - if most of the indicator values are the same, the indicator is arguably not very useful.\nThe Skew/kurtosis column gives the skewness and kurtosis values for each indicator - these are used as simple indicators of outliers: if an indicator has absolute skewness &gt; 2 and kurtosis &gt; 3.5 it is flagged. Outliers can be a problem in the aggregation step: they result in the scale of the indicator being dominated by some few outlying values. Note however that outliers are automatically treated when calculating the results - see Chapter 5.\nThe next two columns, Collinear with and Negatively correlated with give details of any indicators with which the indicators is collinear with (defined as correlation &gt; 0.9), or negatively correlated with (defined as correlation &lt; -0.4), within the same aggregation group at level 2. Collinearity between indicators can point to double counting, where effectively the same information is present in two indicators. Negative correlations can cause problems in aggregation, because high values of one indicator can cancel out low values of the other. It is recommended to check any flagged issues here using the scatter plot tool (described below). Note that the type of correlation used is Spearman rank correlation, which is less sensitive to outliers and skewed distributions.\nFinally, the Status column reports whether the indicator is currently included or excluded (by default all indicators are included). Removal of indicators is explained in the next section.\nAltogether, the table aims to highlight at a glance any possible statistical issues with indicators. Keep in mind that indicators are never “perfect”, and there will likely be various issues flagged in your data set. Of the criteria in the table, the data availability is probably the most important - indicators with low availability can add little, and in the worst case be misleading. The others can be considered as “small flags”, but if an indicator has multiple flags, it could be examined more closely to see whether it is really worth including it or not."
  },
  {
    "objectID": "analysis.html#indicator-information",
    "href": "analysis.html#indicator-information",
    "title": "4  Indicator analysis",
    "section": "4.2 Indicator information",
    "text": "4.2 Indicator information\n\nThe indicator information box reports information about the indicator currently selected in the analysis table. This includes the parent groups which the indicator belongs to, its maximum and minimum values, mean and median, and its data availability. It is worth checking these numbers to make sure they agree with the expected definition of the indicator. For example, an indicator which is a percentage should generally have values in the range 0-100, but certainly not negative. This can be a simple way to spot any errors in compiling the indicator data.\nFinally, this box also includes the option to remove the selected indicator by clicking the “Remove” button, and to restore any removed indicators with the “Restore” button. When an indicator is removed, it is not included in the calculation of the index scores on the following tabs, but the data is still retained in the app so it can easily be replaced.\nIndicators can of course also be added and removed in your input data spreadsheet, and this is probably the best place to make heavy modifications. The in-app feature may be more useful for quick “what if” experiments."
  },
  {
    "objectID": "analysis.html#distribution",
    "href": "analysis.html#distribution",
    "title": "4  Indicator analysis",
    "section": "4.3 Distribution",
    "text": "4.3 Distribution\n\nThe distribution plot shows the statistical distribution of the indicator selected in the analysis table. The intention is to show visually how each indicator might be skewed, or contain outliers. This can also be useful to spot errors, e.g. incorrect data points. Click on the “gear” icon in the top right corner of the box to toggle between a histogram and violin plot.\nAgain, visual inspection of each indicator is highly recommended to double check that the data values follow the kind of distributions and ranges you would expect."
  },
  {
    "objectID": "analysis.html#scatter-plot",
    "href": "analysis.html#scatter-plot",
    "title": "4  Indicator analysis",
    "section": "4.4 Scatter plot",
    "text": "4.4 Scatter plot\n\nThe scatter plot allows to plot any indicator against any other. The x-axis indicator is selected by selecting an row in the analysis table. The y-axis indicator is controlled by clicking the “gear” icon in the top right and using the drop-down menu. Here you can also optionally add a linear trend line and toggle log axes (the latter option useful for skewed indicators). Hovering over points reveals details of the region and values.\nScatter plots are useful to assess the relationships between indicators, but can also identify outliers and help spot any errors. In the analysis table, where indicators are flagged as being collinear or negatively correlated, it is recommended to check them here to see if the relationships reveal anything unusual."
  },
  {
    "objectID": "results.html#calculation-of-results",
    "href": "results.html#calculation-of-results",
    "title": "5  Exploring results",
    "section": "5.1 Calculation of results",
    "text": "5.1 Calculation of results\nWhen you first click on the Results tab, behind the scenes the app runs a series of calculations which result in the index scores, and all the other aggregate scores. This is done automatically so there is no need for any user input. The calculation follows recognised international methodology1, and the steps are as follows:\n\nTreat any outliers\nNormalise indicators onto a 1-100 scale\nAggregate using the weighted arithmetic mean, using the weights specified in your input spreadsheet.\n\nNote that the aggregate scores are scaled in two different ways: either using the 1-100 scale, or they are rescaled onto a categorical 1-5 scale. Both scales can be viewed in the app. The detailed explanation of these steps is left for Chapter 10 and Chapter 11."
  },
  {
    "objectID": "results.html#map-and-table",
    "href": "results.html#map-and-table",
    "title": "5  Exploring results",
    "section": "5.2 Map and table",
    "text": "5.2 Map and table\n\nIn the main “Results” box, the top level of the index is plotted on the map, with colour shading representing the index scores. The map is interactive, allowing you to pan and zoom using by clicking and dragging, or scrolling with the mouse wheel.\nHovering over each region gives further details about the region, including its score and rank. Clicking on a region will open a box in the bottom left with more details, including its scores and ranks for the aggregation level below the index, as well as its overall score and rank. Clicking on the “Go to profile” link here will go to an even more detailed profile of that region, which is explained later in Chapter 6.\nYou can change which indicator or aggregate is plotted on the map using the uppermost dropdown menu in the top right of this box. You can also select whether to view the scores as a 1-5 (categorical) scale or on the 1-100 scale (raw values at the indicator level).\nThe map is downloadable in various formats by selecting the file format (either png, jpeg, pdf or html) and clicking the “download map” link. Capturing the map images is unfortunately not perfect and you may have to experiment a little to get the best results. An alternative, which can offer more control, may be to download the map as an HTML file, then open it in a separate tab, and save the image there using the “print to pdf” functionality in your browser, or to simply take a screenshot (in the latter case, you can maximise the window with F11 and take a screenshot of the full window using Windows’ “snipping” tool, for example).\nIn the same “Results” box you can also select the “Table” tab to see the results as a table.\n\nThe table is colour-formatted to help highlight high and low values. The table rows are sorted by the highest index score downwards, and the columns are sorted from the highest level downwards. You can sort the table by different columns by clicking on the column headers, and search for particular units using the search box."
  },
  {
    "objectID": "results.html#bar-chart",
    "href": "results.html#bar-chart",
    "title": "5  Exploring results",
    "section": "5.3 Bar chart",
    "text": "5.3 Bar chart\n\nUnderneath the Results box, there is a bar chart of the same indicator/aggregate shown on the map. Use the “gear” icon in the top right for more options: by default only the top 50 regions are shown but you can select the bottom 50, or all. The checkbox selects whether to break down scores into their components on the bar chart - these are the underlying indicators aggregates at the level immediately below. Clicking on a bar here will also give details about that region in the box in the bottom left of the map."
  },
  {
    "objectID": "results.html#scenarios",
    "href": "results.html#scenarios",
    "title": "5  Exploring results",
    "section": "5.4 Scenarios",
    "text": "5.4 Scenarios\nBy default the index is calculated using the arithmetic mean, which implies that low (high) scores in one indicator are perfectly compensated by high (low) scores in another. Optionally, select “Scenario 2” which uses the geometric mean: in this case lower scores in one indicator are less compensated by higher scores in others, or “Scenario 3” which implies even less compensation. Click “Recalculate” to see the new results.\nImportantly, the scenario selected here will be used as the “main” results in the rest of the app, including in the “Profiles” and “Region comparison” tabs. All scenarios can additionally be compared in one place in the “Scenarios” tab, which is explained in Chapter 7.\nClicking on the ‘gear’ icon in the top right of this box opens the option to adjust weights. If this is enabled, you can interactively adjust weights for the highest level of the index (below the index). However, in general equal weights are strongly recommended unless there is a specific reason to weight otherwise.\nMore details on the aggregation methods are given in Chapter 11."
  },
  {
    "objectID": "results.html#footnotes",
    "href": "results.html#footnotes",
    "title": "5  Exploring results",
    "section": "",
    "text": "Specifically the JRC/OECD Handbook on Composite Indicators, and guidance from the European Commission’s Competence Centre on Composite Indicators and Scoreboards.↩︎"
  },
  {
    "objectID": "profiles.html#details-table",
    "href": "profiles.html#details-table",
    "title": "6  Region profiles",
    "section": "6.1 Details table",
    "text": "6.1 Details table\nThe Details table gives full details of all aggregate and indicator scores for the selected region. The columns of the table are colour-formatted to help spot higher values at a glance.\n\nThe table can easily be sorted by clicking on the table headers - for example to see which indicators score or rank the highest. It can also be filtered by using the boxes under the table headers, for example filtering only to view indicators (level 1). The Search box allows to filter to specific indicators of interest by entering text there.\nRecall that all data and results can also be downloaded as an Excel spreadsheet, and this is probably the best way to explore the results in fine detail. This is explained in Chapter 2."
  },
  {
    "objectID": "profiles.html#dimensions",
    "href": "profiles.html#dimensions",
    "title": "6  Region profiles",
    "section": "6.2 Dimensions",
    "text": "6.2 Dimensions\nThe Dimensions box aims to show at a glance the scores or indicator values of the selected region, for any selected group.\n\nBy default, the app will show the scores of the region for the aggregates immediately below the index level. Where possible, group scores will be plotted on a radar chart (as shown above), unless the number of aggregates in the group is less than three - in this case, it is not possible to plot a meaningful radar chart, and a table will be displayed.\nTo change which group to show, click the “gear” icon in the top right of the box, and select the group to display using the dropdown. Here you can also toggle between a table and a radar chart (the latter only where possible, as mentioned above)."
  },
  {
    "objectID": "profiles.html#highestlowest-ranks",
    "href": "profiles.html#highestlowest-ranks",
    "title": "6  Region profiles",
    "section": "6.3 Highest/lowest ranks",
    "text": "6.3 Highest/lowest ranks\nThe last two boxes on this tab show the highest and lowest ranked indicators as tables.\n\nThese tables are composed by searching across all indicators and displaying those with the five highest and lowest ranks across all regions. This can help to point to specific indicators that are driving high or low scores at the index level."
  },
  {
    "objectID": "scenarios.html#table",
    "href": "scenarios.html#table",
    "title": "7  Scenarios",
    "section": "7.1 Table",
    "text": "7.1 Table\nThe main output here is the scenario comparison table. By default, this displays the ranks of each region, with columns for each scenario. The table can be sorted by clicking on the headers, allowing to sort by each scenario. The colour formatting intends to highlight where scores differ from one scenario to the next.\n\nClicking on the “gear” icon in the top right of this box gives various options for adjusting the table. In the first dropdown you can select whether to use ranks (default) or scores as the basis of comparison. In general, when comparing between different methodologies, ranks make more sense in that changing the aggregation method can lead to scores on quite different scales.\nThe second dropdown can be used to display either the rank/score values, or the (absolute) differences between each scenario and the “base” scenario. The base scenario is the one in the leftmost scenario column, and this can be changed by the third dropdown menu. Examining rank differences in particular is useful to highlight regions which are particularly affected by scenario changes. If a region is sensitive to the scenario, it may be worth examining it more closely to find out why, in the profile tab or else by downloading the data."
  },
  {
    "objectID": "scenarios.html#scatter-plot",
    "href": "scenarios.html#scatter-plot",
    "title": "7  Scenarios",
    "section": "7.2 Scatter plot",
    "text": "7.2 Scatter plot\nThe scatter plot on the right gives a visual comparison of any pair of scenarios. By default this shows the ranks of the first two scenarios plotted against each other. Hovering over each point gives the name of the region. The scatter plot is a useful visual tool to see at a glance the spread between two scenarios, and which regions change the most.\n\nClicking on the “gear” icon reveals some more options: you can select which scenarios to plot on the x and y axes, and also whether to plot the ranks or the scores."
  },
  {
    "objectID": "unit_comparison.html",
    "href": "unit_comparison.html",
    "title": "8  Region comparisons",
    "section": "",
    "text": "The final tab in the app is dedicated to comparisons between regions. This is a simple interface, where the two regions to compare against each other are selected using the first two dropdown menus at the top of the page. The values to show in the table are controlled by the third dropdown menu - either as ranks, scores or the severity category.\n\nThe table is similar to the “Details” table on the “Profiles” tab. It shows the values for each aggregate and indicator, from the index level downwards, and also shows the parent group. The score/rank/categorical columns are colour coded such that the unit with the highest value is highlighted. This is intended to show visually where one region is more “severe” than the other.\nAs with other tables, you can sort and filter the table by clicking on the headers and using the boxes, respectively."
  },
  {
    "objectID": "meth_overview.html#composite-indicators",
    "href": "meth_overview.html#composite-indicators",
    "title": "9  Overview",
    "section": "9.1 Composite indicators",
    "text": "9.1 Composite indicators\nIndicators are used in many contexts to measure complex multidimensional concepts, typically with the aim of prioritising resources and interventions, and also to track progress. In the international/policy context, indicators are often used to compare countries and/or sub-national regions.\nQuite often, the concept to be measured cannot be sufficiently captured with one indicator, and a group of indicators is needed. As the number of indicators gets larger, it becomes increasingly difficult to compare and prioritise.\nComposite indicators are mathematical aggregations of a set of indicators into a single measure. Indicators are organised into conceptual groups which aim to follow a map of the concept to be measured. Aggregating the indicators into a single composite indicator allows quick and easy comparisons, clear communication with stakeholders, and acts as a natural entry point to the data set underneath.\nImportantly, in building a composite indicator, we do not wish to substitute the underlying data, but rather to complement it with an overview measure. Composite indicators involve a number of subjective decisions in their construction, and cannot fully capture all information in the indicator set underneath. However, used carefully, they are a valuable addition and entry point to a complex data set."
  },
  {
    "objectID": "meth_overview.html#index-construction",
    "href": "meth_overview.html#index-construction",
    "title": "9  Overview",
    "section": "9.2 Index construction",
    "text": "9.2 Index construction\nThe index construction follows recognised international methodology for composite indicators1, and the steps are as follows:\n\nClean data input\nTreat any outliers\nNormalise indicators onto a 1-100 scale\nAggregate using the selected aggregation method (scenario), using the weights specified in your input spreadsheet.\n\nWhen the user has input their data, the app first removes any indicators or regions with no data points, since they cannot be used in the calculation. This is also explained in Chapter 3. The other steps are explained in more detail in the next two chapters."
  },
  {
    "objectID": "meth_overview.html#technical-implementation",
    "href": "meth_overview.html#technical-implementation",
    "title": "9  Overview",
    "section": "9.3 Technical implementation",
    "text": "9.3 Technical implementation\nThe A2SIT app is written in R, using Shiny as its front end. The back end of the package makes extensive use of the COINr package, which is an R package for developing and analysing composite indicators.\nThe key steps in terms of constructing the index in COINr are:\n\nBuilding the “coin” object, which is in the f_data_input() function (see on GitHub).\nBuilding the index, which is in the f_build_index() function (see on GitHub).\n\nIn the next two chapters, we also point to the COINr code that is used in building the index. In Chapter 12 a more technical explanation of the general code setup is given."
  },
  {
    "objectID": "meth_overview.html#footnotes",
    "href": "meth_overview.html#footnotes",
    "title": "9  Overview",
    "section": "",
    "text": "Specifically the JRC/OECD Handbook on Composite Indicators, and guidance from the European Commission’s Competence Centre on Composite Indicators and Scoreboards.↩︎"
  },
  {
    "objectID": "data_processing.html#outlier-treatment",
    "href": "data_processing.html#outlier-treatment",
    "title": "10  Data processing",
    "section": "10.1 Outlier treatment",
    "text": "10.1 Outlier treatment\nOutliers are roughly defined as data points that don’t fit the rest of the distribution of the indicator. Consider the artificial example below:\n\n\n\n\n\nExample of a distribution with an outlier.\n\n\n\n\nOutliers can exist because of errors in measurement and data processing, and should always be double-checked. But often, they are simply a reflection of reality. Outliers and skewed distributions are common in socio-economic variables.\nOutlier treatment is the process of altering indicator values to improve their statistical properties, mainly for the purposes of aggregation. The reason why we may want to treat outliers is that in composite indicators, before aggregating we typically normalise the data by scaling it onto a common range (e.g. 0-100). When an indicator has outlying values, as in the example above, the outlier will “dominate” the scale and result in a large part of the indicator scale being empty.\nTypically the implication is that the large majority of points (Admin-2 regions here) end up with either a very low score (or high, depending on which side the outlier is on), except for the outlier. This can turn the indicator into a trivial measure of “is the observation the outlying region or not?”, which is not usually what we want to measure.\nConsider that data treatment is simply another assumption in a statistical process. Like any other step or assumption though, any data treatment should be carefully recorded and its implications understood.\nThe A2SIT app has an outlier treatment algorithm which treats outliers automatically when the results are calculated. The methodology follows that used by the European Commission, among others, and is as follows.\nFor each indicator separately:\n\nCheck skew and kurtosis value\nIf absolute skew is greater than 2 AND kurtosis is greater than 3.5:\n\nSuccessively Winsorise up to a maximum of five points. If either skew or kurtosis goes below thresholds, stop. If after reaching the maximum number of points, both thresholds are still exceeded, then:\nReturn the indicator to its original state, and perform a modified log transformation.\n\nIf the indicator does not exceed both thresholds, leave it untreated.\n\nHere, the skew and kurtosis thresholds are used as simple indicators of distributions with outliers.\nWinsorisation involves reassigning outlying points to the next highest or lowest point, depending on the direction of the outlier. In the example above, this would involve taking the outlier with a value of 10, and reassigning it to the maximum value of the observed points except that one. This treatment can be applied iteratively, in case of multiple outliers.\nThe log transformation involves applying a scaled log-transformation that reshapes the entire distribution. It is most suitable for naturally skewed distributions such as log-normal distributions. Since the direction of skew can be either positive or negative, the transformation adapts accordingly. For positively-skewed indicators:\n\\[\nx' = \\log(x-\\min(x) + a)\\\\\n\\text{where:} \\;\\;\\;  a = 0.01(\\max(x)-\\min(x))`\n\\]\nElse if the skew is negative:\n\\[\nx' = -\\log(\\max(x) + a - x)\\\\\n\\]\nThis transformation is effectively a log transformation with a small shift, which ensures that negative values can also be transformed."
  },
  {
    "objectID": "data_processing.html#normalisation",
    "href": "data_processing.html#normalisation",
    "title": "10  Data processing",
    "section": "10.2 Normalisation",
    "text": "10.2 Normalisation\nThe normalisation step aims to bring indicators onto a common scale, which makes them comparable for the purposes of aggregation. The A2SIT app uses the common “min-max” approach, which simply rescales each indicator onto the \\([1, 100]\\) interval:\n\\[ x' = \\frac{ x - x_{\\text{min}} }{ x_{\\text{max}} - x_{\\text{min}} } \\times (100-1) + 1\\]\nwhere \\(x'\\) is the normalised indicator value. This means that the lowest observed value of each indicator, over all Admin-2 regions, will get a score of 1, and the highest observed value will get a score of 100.\nThe min-max method is simple to understand and communicate. We set the lower bound at 1 to acknowledge the fact that the minimum value does not imply a true zero in that indicator (i.e. there is not an absence of severity).\nNote that the app additionally uses an ex-post rescaling onto a 1-5 categorical scale. This is explained more in the following chapter."
  },
  {
    "objectID": "data_processing.html#coinr-implementation",
    "href": "data_processing.html#coinr-implementation",
    "title": "10  Data processing",
    "section": "10.3 COINr implementation",
    "text": "10.3 COINr implementation\nThe relevant code for these steps can be found in the f_build_index() function, which is on GitHub here. In COINr, the code looks like this:\n\nmax_winsorisation &lt;- 5\nskew_thresh &lt;- 2\nkurt_thresh &lt;- 3.5\n\n# treat outliers\ncoin &lt;- COINr::qTreat(\n  coin, dset = \"Raw\",\n  winmax = max_winsorisation,\n  skew_thresh = skew_thresh,\n  kurt_thresh = kurt_thresh,\n  f2 = \"log_CT_plus\")\n\n# normalise to [1, 100]: otherwise if we have zeros can't use geometric mean\ncoin &lt;- COINr::Normalise(\n  coin,\n  dset = \"Treated\",\n  global_specs = list(f_n = \"n_minmax\",\n                      f_n_para = list(l_u = c(1, 100)))\n)"
  },
  {
    "objectID": "aggregation_weighting.html#weighting",
    "href": "aggregation_weighting.html#weighting",
    "title": "11  Aggregation and weighting",
    "section": "11.1 Weighting",
    "text": "11.1 Weighting\nIn the input file to the A2SIT app, the user can specify weights for each indicator, and for all aggregates up to the index level. Weights are used in the aggregation step, and are rescaled to sum to 1 within each aggregation group.\nDefining weights is a delicate business. Generally, the starting point should always be equal weights. You may wish to change weights in specific circumstances, for example if a panel of experts believes that one indicator or aggregate is significantly more important than the others in the group. Consider, however, that weights will always be contested, and equal weights are usually more defensible. However everything depends on context.\nConsider also that the structure of the index is important in defining the individual weights of the indicators - this is evident from looking at the framework plot of the index (using the example data):\n\nSome indicators are effectively weighted less because there are more of them in their aggregation group. The final weight of each indicator in the index is therefore due to the indicator weight, but also due to the weights of its parent groups, and the structure of the index. The framework plot above is in many ways the best way to visualise the index structure, in that it captures these complex interactions between weights and structure.\nIf you find that a given indicator or aggregate is not weighted according to your view of the concept, it may be an indication that the structure of the index should be reformulated, as opposed to reweighting the components. This can also lead to a more transparent outcome. Above all, avoid tuning weights to achieve a pre-conceived outcome."
  },
  {
    "objectID": "aggregation_weighting.html#aggregation",
    "href": "aggregation_weighting.html#aggregation",
    "title": "11  Aggregation and weighting",
    "section": "11.2 Aggregation",
    "text": "11.2 Aggregation\nAggregation is mathematically combining indicators together. At the time of writing, the following aggregation methods are implemented in the A2SIT app:\n\nWeighted arithmetic mean\nWeighted geometric mean\n\nIt is important to realise that different aggregation methods have different properties, and correspondingly the choice of aggregation method will affect the results. In fact, the aggregation method can have quite a large impact on the results. In the app, aggregation methods are referred to as “Scenarios”, reflecting the fact that they lead to fairly different results. To understand which is best for your use-case, the methods are explained here.\n\n11.2.1 Arithmetic mean\nThe arithmetic mean is the familiar and ubiquitous “average”. Here, we use the weighted version. Denoting a group of indicators as \\(x_i \\in \\{x_1, x_2, ... , x_d \\}\\), the weighted arithmetic mean is calculated as:\n\\[ y = \\frac{1}{\\sum_{i=1}^d w_i} \\sum_{i=1}^d x_iw_i \\]\nwhere the \\(w_i\\) are the weights corresponding to each \\(x_i\\). Here, if the weights are chosen to sum to 1, it will simplify to the weighted sum of the indicators. In any case, the weighted mean is scaled by the sum of the weights, so weights operate relative to each other.\nImportantly, the arithmetic mean has “perfect compensability”, which means that a high score in one indicator will perfectly compensate a low score in another. In a simple example with two indicators scaled between 0 and 10 and equal weighting, a unit with scores (0, 10) would be given the same score as a unit with scores (5, 5) – both have a score of 5.\n\n\n11.2.2 Geometric mean\nAn alternative is the weighted geometric mean, which uses the product of the indicators rather than the sum.\n\\[ y = \\left( \\prod_{i=1}^d x_i^{w_i} \\right)^{1 / \\sum_{i=1}^d w_i} \\]\nThis is simply the product of each indicator to the power of its weight, all raised the the power of the inverse of the sum of the weights.\nThe geometric mean is less compensatory than the arithmetic mean – low values in one indicator only partially substitute high values in others. For this reason, the geometric mean may sometimes be preferred when indicators represent “essentials”. An example might be quality of life: a longer life expectancy perhaps should not compensate severe restrictions on personal freedoms.\n\n\n11.2.3 Harmonic mean\nThe final aggregation method is the harmonic mean, which implies even less compensation between indicators than the geometric mean. It uses the mean of the reciprocals of the indicators:\n\\[ y = \\frac{\\sum_{i=1}^d w_i}{\\sum_{i=1}^d w_i/x_i} \\]\nThe harmonic mean is the last of the three so-called Pythagorean means, and is often used for taking the mean of rates and ratios. However it can also be used as a general approach for providing very little compensation between indicators; a region will only get a high score if almost all of its indicators have high scores.\nThe figure below shows how the three aggregation methods differ. In this simple example, two indicators on the \\([1, 100]\\) scale are aggregated together with equal weights - the first indicator x1 has values from 1-100, and the second always has the same value of 50.\n\n\n\n\n\nThe plot shows that the arithmetic mean is linear with respect to x1. However the geometric mean is not: in particular, low scores of x1 will result in a quite low aggregated score, approaching zero, despite the fact that the other indicator has a value of 50. The geometric mean never gives an aggregate score higher than the arithmetic mean. The harmonic mean is even less compensatory and provides scores always lower than the geometric mean.\nWhichever aggregation method is chosen, all Admin-2 regions will be treated the same. Scores in composite indicators are dimensionless, so comparing scores between arithmetic and geometric means is not usually helpful. Usually it is better to compare ranks. Luckily, the A2SIT app has a tool for comparing scenarios which is described in Chapter 7."
  },
  {
    "objectID": "aggregation_weighting.html#categorical-rescaling",
    "href": "aggregation_weighting.html#categorical-rescaling",
    "title": "11  Aggregation and weighting",
    "section": "11.3 Categorical rescaling",
    "text": "11.3 Categorical rescaling\nThe scores that are produced from aggregating indicators will be on the \\([0,100]\\) scale, since they are the means of indicators on that scale. In the A2SIT app, there is an additional rescaling performed onto a categorical 1-5 scale. This is to simplify the interpretation of the scores: a score of 5 can be always considered high, and a score of 1 is always low. This rescaling is performed after aggregation, and is applied to all aggregate scores. The app lets you switch between the 1-5 scale or the 1-100 scale.\nThe 1-5 scale is created by dividing the observed range of each aggregate into five equally-sized intervals. The transformation looks like this:\n\n\n\n\n\nSince the transformation is based on the observed range, it means that category 1 is defined as “the lowest fifth of the observed values of the indicator”. Importantly, the score range of this for one indicator will be different from the next."
  },
  {
    "objectID": "aggregation_weighting.html#coinr-implementation",
    "href": "aggregation_weighting.html#coinr-implementation",
    "title": "11  Aggregation and weighting",
    "section": "11.4 COINr implementation",
    "text": "11.4 COINr implementation\nThe COINr code for aggregation can be found in the f_build_index() function. The following is an extract:\n\n# aggregate\ncoin &lt;- COINr::Aggregate(coin, dset = \"Normalised\", f_ag = agg_method)\n\n# generate results tables\ncoin &lt;- f_generate_results(coin)\n\n# add severity level df\ncoin &lt;- f_make_severity_level_dset(coin)\n\nThe full code can be found on GitHub."
  },
  {
    "objectID": "technical_implementation.html#package-overview",
    "href": "technical_implementation.html#package-overview",
    "title": "12  Technical implementation",
    "section": "12.1 Package overview",
    "text": "12.1 Package overview\nThe A2SIT package is set up as a typical R package - for an overview of R package structure see the R Packages book.\n\nfs::dir_tree(\"../\", recurse = F)\n\n../\n├── A2SIT.Rproj\n├── A2SIT_Doc\n├── app.R\n├── data\n├── DESCRIPTION\n├── dev\n├── docs\n├── inst\n├── LICENSE\n├── LICENSE.md\n├── man\n├── NAMESPACE\n├── NEWS.md\n├── not_package\n├── R\n├── README.md\n├── shiny_bookmarks\n├── tests\n└── vignettes\n\n\nThe main folders of interest here are:\n\n/R, which contains all the R code for the front and back end of the app\n/A2SIT_Doc, which is the source files for the long-form documentation (this book)\n/Data, which contains data saved within the package\n/Docs, which is the rendered version of the long-form documentation (this book)\n/inst. which contains accessory files and resources that are used within the app\n/man, which is the function documentation\n/tests, which are the unit tests\n\nThe remaining folders are either created by the Golem package, which has been used to help deploy the app, or are related to smaller technical things such as Shiny bookmarking (explained later). The other files in the top level directory relate to deploying the app (app.R), and to the package itself."
  },
  {
    "objectID": "technical_implementation.html#code-overview",
    "href": "technical_implementation.html#code-overview",
    "title": "12  Technical implementation",
    "section": "12.2 Code overview",
    "text": "12.2 Code overview\nAll code is found in the /R folder, as required by R package convention. The R files here aim to follow reasonably intuitive naming conventions.\nTo begin with, the app is run by calling the run_app() function, which lives in the run_app.R file. This is the starting point of the app, and if you want to see how the code is structured you should start here and follow the trail.\nConsider that to run the app, if you have installed the package you will need to first call library(A2SIT). If you have cloned the repo (see later in this chapter) and you are working with the source code, you will need to use devtools::load_all(\".\") to load the functions of the package into the namespace.\nAt the next level down, the UI and Server functions which define the Shiny app are found in the app_server.R and app_UI.R functions respectively. If you are not familiar with the structure of a Shiny app, the Mastering Shiny book is an excellent resource.\nThe app is built using Shiny modules, and each module is contained within files following a mod_*.R naming pattern. The modules each correspond to the seven tabs in the app.\nThe modules call back-end functions which live in files following a f_*.R naming pattern. There is one of these files for each module, except the “Welcome” module/tab.\nThere are also a number of utility functions which are used between modules, and these live in files named as utils_*.R. The remaining files are either generated by Golem but not used very much, or relate to specific things which are mentioned later."
  },
  {
    "objectID": "technical_implementation.html#back-end",
    "href": "technical_implementation.html#back-end",
    "title": "12  Technical implementation",
    "section": "12.3 Back-end",
    "text": "12.3 Back-end\nA first version of the back-end code for the app was encapsulated in a standalone R package called MVI_Guatemala. This was developed before the front end of the app, and since the back end code had to be heavily modified and extended, it was simply copied into the present A2SIT package, rather than calling the previous package and needing to edit/maintain two packages. Therefore the previous package still exists as a kind of “legacy” version of the current package.\nTo understand the back end structure of the app, the best place to start is in app_sever.R, which defines the server function of the app. Here you will find:\n\nShared reactive variables which are passed between modules\nThe modules themselves, and variables which are explicitly passed to them\nSome specific components that exist outside of the modules, such as export to Excel and R, the modal help windows, and the bookmarking feature\n\nTo understand each of these features, it is necessary to follow the functions called there. To give a little help, the modal help windows are written in markdown files which live in the ./inst/md-help folder, and are displayed using the “bsplus” package. Shiny bookmarking uses the “server” implementation, but additionally adds the coin to the saved file. Shiny bookmarks create folders in the ./shiny_bookmarks directory.\n\n12.3.1 Data flow\nThe app is based around the COINr package, as mentioned previously. COINr encapsulates a composite indicator in an object called a “coin”, which can be manipulated by COINr functions and used to return information and plots. The coin is therefore the central object in the app.\nIn the input module, the user uploads a formatted spreadsheet of data and metadata, which is read by the app and used to build a coin. This task is performed by the f_data_input() function. The function reads the user spreadsheet and manipulates the data so that it can be used to create a coin. It also removes any indicators/units without data, and tries to catch any user errors in formatting and return helpful error messages.\nThe coin is then passed to the analysis module, which largely returns outputs to the user such as plots and tables. Here, users can optionally remove indicators, so this implies some small modifications to the coin.\nNext, the coin is passed to the results module when the user arrives there. This triggers the results to be calculated, which implies running the f_build_index() function, and calculating alternative scenarios via the get_scenarios() function.\nThe tabs following this do not edit the coin - they simply read from it and display outputs. At any time, the coin is used to generate an Excel output using the f_export_to_excel() function, or to write the coin to an .Rdata file.\n\n\n12.3.2 Mapping and geometry\nIt is worth saying a few particular words about maps and Admin-2 codes.\nThe A2SIT app aims to calculate scores at the Admin-2 level for a given country, AND to generate maps of the results. In order for this to work, it needs a geometry file for each country which defines the Admin-2 regions within that country. Moreover, each region should be referenced by a unique code which can be used within the app.\nAlthough in theory the geometry files are available from the UNHCR’s gis.unhcr.org sever, extracting the files in the correct format has proven to be difficult. In short this is because:\n\nThe API tends to time out for some countries, so in practice the geometry can’t be retrieved\nThere doesn’t seem to be a harmonised system of Admin-2 codes, and codes are sometimes duplicated, which violates the requirements of COINr\nGeometry files can be large, and some cannot be simplified.\n\nAt the time of writing, this is still an ongoing issue, and a discussion can be found on GitHub.\nLeaving these pending issues aside, the A2SIT app has a function called cache_admin2_geometry() which queries the API and, if successful, stores the geometry for a given set of ISO3 codes. It also tries to simplify the geometry using the “sf” package.\nThe map files that are successfully retrieved are stored as .RDS files within the app’s /inst/geom folder, each of which contains a spatial polyogon data frame which can be read by leaflet. These map files are used at various points:\n\nTo tell the user which countries are available for data input in the app (the dropdown menu on the “Upload” tab).\nTo generate data input templates: the Admin-2 codes from the geometry files are used as unit codes and added to the base template. This ensures that they can be matched back to the geometry file later.\nTo plot the maps: the user’s data is merged with the geometry file, and this enables it to be plotted.\n\nThe objective would be to have geometry files for as many countries as possible, although as mentioned this is a work in progress. Note that even for the stored geometry files, some have duplicate codes, and/or missing names."
  },
  {
    "objectID": "technical_implementation.html#front-end",
    "href": "technical_implementation.html#front-end",
    "title": "12  Technical implementation",
    "section": "12.4 Front-end",
    "text": "12.4 Front-end\nThe app is built using Shiny, specifically using shinydashboard and shinydashboardplus. These packages give the “box” layout of the app, and also enable the sidebar menu, collapsible boxes and pop-out side bars in the boxes.\nThe UI of the app is defined in the app_UI.R file, where the menu items, tabs and headers/footers are specified. As mentioned previously, each tab corresponds to a Shiny module, so the UI functions can be found within the corresponding module files.\nThe app makes quite heavy use of add-on packages for specific functions, many of which are wrappers for JavaScript libraries, among which:\n\nbsplus (modal help)\ncicerone (guided tour on Welcome tab)\nhtmlwidgets (interactive graphics)\nleaflet (maps)\nplotly (interactive plots)\nshinyjs (adding/hiding page elements)\nshinyWidgets (enhanced user inputs)\nwebshot (exporting maps as images)\n\nNotably, the appearance of the app is also controlled by the unhcrshiny package, which specifies the CSS.\nApart from the main UI code which is found in app_UI.R and the module files for each tab, a number of auxilliary functions are found in the utils_ui.R file."
  },
  {
    "objectID": "technical_implementation.html#documentation",
    "href": "technical_implementation.html#documentation",
    "title": "12  Technical implementation",
    "section": "12.5 Documentation",
    "text": "12.5 Documentation\nAs an R package, the app is firstly documented in the usual way by documenting each function with a description, inputs and outputs, and so on. When the package is installed, this help is rendered and available in an R session by running the usual ?function_name command. The package doesn’t however contain any vignettes; rather everything is contained in this online book. The book is built using quarto, and the source files are available in ./A2SIT_Doc (this may be moved to ./inst at some point).\nTo edit the book, simply edit the source files which are written in Markdown. To render the book the easiest way is to open the book .Rproj file, which is also in ./A2SIT_Doc, in RStudio. Then, as long as quarto is installed, you should be able to click the “Render Book” button in the “Build” tab, in the upper right of the GUI. This will rebuild the entire book. Individual pages can be built by clicking the “Render” button in the file editing pane."
  },
  {
    "objectID": "technical_implementation.html#contributing",
    "href": "technical_implementation.html#contributing",
    "title": "12  Technical implementation",
    "section": "12.6 Contributing",
    "text": "12.6 Contributing\nThe A2SIT package is hosted on a public GitHub repo at https://github.com/UNHCR-Guatemala/A2SIT.\nTo flag a bug, or suggest a new feature, open an issue.\nIf you wish to contribute code to the A2SIT package, you should:\n\nClone the repo\nCreate a new branch\nMake your edits\nCreate a pull request\n\nIf any of these steps are unclear, a good resource for using Git and GitHub in the context of R is the Happy Git with R book. There are also countless general resources for Git and GitHub out there in the wild."
  }
]